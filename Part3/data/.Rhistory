#T & T -> T, T & F -> F, F & F -> F
#T | T -> T, T | F -> T, F | F -> F
3 & 9
3 & 0
1 | 4
1 | 0
class(3 & 9)    #TRUE, FALSE 는 logical 클래스
#NA: 잘못된 값 들어옴 (Not Applicable), NULL: 값이 안 나옴.
cat(1,NA,2) #단순 출력이므로 NA 는 상관없음
cat(1,NULL,2) #NULL 은 아예 값이 없으므로 출력이 안됨
sum(1,NA,2) #덧셈연산에 NA는 해당이 안 되므로 계산자체가 불가능
sum(1,NULL,2) #덧셈에서 NULL = 0 과 같으므로 상관 없음
#na.rm = T, NA 값 = True 라면 remove 해라
sum(1, NA, 2, na.rm = T)
class(NA)     #NA 는 logical 클래스
class(NULL)   #NULL 은 자체로 NULL 클래스
#작업용 기본 디렉토리 설정은 setwd (디렉토리 주소)
setwd ("D:/Workspace/R_data_analysis/Part3/data")
txt1 <- read.csv("factor_test.txt") #read.csv(~.csv) 주어진 csv 파일을 읽어서 변수에 대입
txt1
factor1 <- factor(txt1$no) #factor(csv대입변수이름$데이터를 구분하는 열의 이름)
#                           특정데이터의 자료들을 출력 (그 열의 행자료들을 출력)
factor1
factor2 <- factor(txt1$sex)
factor2
summary1 <- summary(factor2) #summary() 특정데이터 자료들을 빈도에 따라 정리, 출력
summary1
class(factor(txt1$sex))
class(factor2)
Sys.Date()
Sys.time()
source('D:/Workspace/R_data_analysis/Part3/sec_4.R', encoding = 'UTF-8', echo=TRUE)
class(Sys.date())
date()       #미국 식 시간표기 : Thu May 30 09:16:47 2019
class(Sys.Date())
as.Date("2019-05-30")
class(d)
#"2019-05-30"을 그냥 type하면 character 클래스. 이것을 date 타입으로 바꾸기위해 as.Date(" ")을 사용
d <- as.Date("2019-05-30")
class(d)
#"2019-05-30"을 그냥 type하면 character 클래스. 이것을 date 타입으로 바꾸기위해 as.Date(" ")을 사용
class("2019-05-30")
as.Date("19-05-30")
as.Date("05-30-2019", format="%d-%m-%Y")
as.Date("30-05-2019", format="%d-%m-%Y")
as.Date("190530", format="%y-%m-%d")
as.Date("190530", format="%y%m%d")
as.Date("2019년 05월 30일", format="%Y년 %m월 %d일")
as.Date("05-30", format="%m-%d")
as.Date(10, origin="2019-05-30")
as.Date(10, origin=Sys.date())
as.Date(10, origin=Sys.Date())
"2019-05-30" - "2019-05-27"
as.Date("2019-05-30") - as.Date("2019-05-27")
as.Date("2019-11-14") - Sys.Date()   #as.Date으로 변환 후에는 가능함
as.Date("2019-05-30 20:00:00") - as.Date("2019-05-30 12:00:00")
as.POSIXct("2019-05-30 20:00:00") - as.POSIXct("2019-05-30 12:00:00")
as.POSIXct("2019-05-30 20:00:00") - as.POSIXct("2019-05-30 12:00:00")  #POSIXct 초 단위로 ㄱㄱ
as.POSIXct("2019-05-30 20:00:00") - as.POSIXct("2019-05-30 12:10:04")  #POSIXct 초 단위로 계산한 시간차를 출력 (초 말고 보기 쉬운 더 큰 단위로 출력됨)
install.packages("lubridate")
library(lubridate)
now
now()
year(date)
month(date)
date <- now() #lubridate 설치 후 더 빠르게 바뀐, 새로운 함수
month(date)
month(d)
wday(date)
day(date)
wday(date, label = T)
month(date, label=T)
d <- d - days(2)
d
d + years(1)
d+months(-3)
d+months(-2)
d-months(2)
d
d
d <- hm("22:30")
d
d
d <- hms("22:30:14")   #hms --> hours, minutes, seconds 시간,분,초 대입
d
var <- c("a","b","c")
source('D:/Workspace/R_data_analysis/Part3/sec_5.R', encoding = 'UTF-8', echo=TRUE)
111->var1->var2
var1 ; var2
var3 ; var4
var3 ; var4
var3 <- var4<-222
var3 ; var4
var <- c(1, 2, 3)
var
111->var1->var2     #값을 연속적으로 할당
var3 ; var4
string1 <- "V Easy R Programming" ; string1
string2 <- 'he said "I ate breakfast"'
string2 <- 'he said "I ate breakfast"' ; string2
var <- c("a","b","c")   #a, b, c 라는 각각의 문자 데이터를 한번에 담음 --> Array 형태
var
var <- c(1, 2, 3)
var
111->var1->var2     #값을 연속적으로 할당
var1 ; var2
var3 <- var4<-222   #rotation 할당 화살표 방향은 아무쪽이나 상관없다
var3 ; var4
string1 <- "V Easy R Programming" ; string1
string2 <- 'V Easy R'
string3 <- 'he said "I ate breakfast"' ;
string3  #"" 를 '' 안에 넣으면 큰따옴표 대신 백슬래쉬 사이에 대화체로 묶는다
string2 <- 'V Easy R' ; string2
string3  #"" 를 '' 안에 넣으면 큰따옴표 대신 백슬래쉬 사이에 대화체로 묶는다
strnig4
string4 <- 'he said /"I ate breakfast"/'
strnig4
string4
string3  # " " 를 ' ' 안에 넣으면 큰따옴표 앞뒤로로 백슬래쉬 사이에 대화체로 묶는다
string4
string4 <- 'he said \"I ate breakfast"\'
string4
string4 <- 'he said \"I ate breakfast"\'
string4
string4 <- 'he said \"I ate breakfast"\'
string4
string4 <- 'he said \"I ate breakfast"\'
string4
string4 <- 'he said \"I ate breakfast\"'
string4 <- "he said \"I ate breakfast\""
num1 + num2
var <- c("a","b","c")   #a, b, c 라는 각각의 문자 데이터를 한번에 담음 --> Array 형태
var
var <- c(1, 2, 3)
var
111->var1->var2     #값을 연속적으로 할당
var1 ; var2
var3 <- var4<-222   #rotation 할당 화살표 방향은 아무쪽이나 상관없다
var3 ; var4
string1 <- "V Easy R Programming" ; string1
string2 <- 'V Easy R' ; string2     #작은 따옴표로 묶어도 문자열은 무조건 "  " 로 출력됨
string3 <- 'he said "I ate breakfast"' ;
string3  # " " 를 ' ' 안에 넣으면 큰따옴표 앞뒤로 백슬래쉬 사이에 대화체로 묶는다
string4 <- "he said \"I ate breakfast\""
string4
num1 <- 1
num2 <- 2
num1 + num2
char1 <- "a"
num1 + char1
seq1 <- 1:5 ; seq1
#이러한 기능은 Python 에도 적용. 이러한 점이 엄청난 양의 데이터를 분석할 때 도움이 된다
seq1 <- "a":"f"
date1 <- seq(from=Sys.Date(), to=(Sys.Date() + months(1)) , by=1)
date1
date2
date2 <- seq(from=Sys.Date(), to=(Sys.Date() + years(1)) , by='month')
date2
date3 <- seq(from=as.Date('2014-04-29'), to=Sys.Date(), by='year')
date3
Objects
objects()
.hidden <-3
objects()
.hidden
rm(date1)
objects()
ls
ls()
rm(list = ls())
ls()
ls()
objects()
.hidden
vec1 <- c(1,2,3,4,5)
vec1 <- c(1:5)
vec1
# CRUD (Create Retrieve Update Delete)
vec1(3)
# CRUD (Create Retrieve Update Delete)
vec1[3]
vec1[-3]
vec1[-1:3]  # 벡터배열을 출력할때 주어진 인덱스 넘버의 값만 빼고 보여줌
source('D:/Workspace/R_data_analysis/Part3/sec_6.R', encoding = 'UTF-8', echo=TRUE)
length(vec1)
vec1[1:(length(vec1)-1)]
vec1[3] <- 2 ; vec1
vec1[3] <- 6 ; vec1
vec1 <- c(vec1, 7, 8) ; vec1
vec1[9] <- 9 ; vec1
vec1
append (vec1, 10, after=3)
append (vec1, c(-1, -2), after=8)
vec1
append (vec1, c(-1, -2), after=7)
vec1 <- append (vec1, c(-1, -2), after=7)
vec1
vec1 <- append(vec1, 100, after=0)
vec1
c(1,2,3) + c(4,5,6)
c(1,2,3) + 1
var1 <- c(1,2,3) ; var2 <- c(4,5,6)
var1+var2
var3 <- c('1','2','3')
var1 + var3
union(var1, var3)
union(var1, var3) #
#union(배열1, 2: 다른 클래스여도 됨) --> 합집합 만듦. 이 때 말 그대로 교집합, 겹치는 값은 제외, 중복 없는 결과
var4 <- c(1,2,3,4,5)
var1; var4
var1 + var4
#이 때 짧은 벡터를 그것이 끝난 부분부터 다시 1로 돌아와서 연산
var5 <- c(1,2,3,4,5,6)
var1 + var5
#이 때 짧은 벡터를 그것이 끝난 부분부터 다시 1로 돌아와서 연산
var5 <- c(1,2,3,4,5,6,7)
var1 + var5
var1 + var5   #여기서는 var5가 더 길지만 길이가 6으로 var1 의 길이는 3, 둘은 배수이므로 warning 없음음
source('D:/Workspace/R_data_analysis/Part3/sec_6.R', encoding = 'UTF-8', echo=TRUE)
var1 + var5   #여기서는 var5가 더 길지만 길이가 6으로 var1 의 길이는 3, 둘은 배수이므로 warning 없음음
#Load and Save Data
#작업용 기본 working directory 를 R Studio Tools->gobal->working direc 에서 data 폴더로 설정
list.files()  # working direc의 저장된 모든 파일 이름들 보여줌
list.files(all.files = T) #숨김 파일까지 보여줌
scan1 <- scan('scan_1.txt') ; scan1
scan2 <- scan('scan_2.txt') ; scan2 #소수점 데이터 포함하는데 그것이 제대로 읽히질 않음
scan2 <- scan('scan_2.txt', what= "") ; scan2 #소수점 데이터를 제대로 읽는대신 캐릭터/스트링으로 변환시켜 내보냄
scan3 <-scan ('scan_3.txt', what="") ; scan3 #what="" 가 스트링 관련
scan4 <-scan ('scan_4.txt', what="") ; scan4 #스트링들은 그냥 스트링으로 나옴
input<-scan()  #사용자로부터 input 받음
input <- scan(what="")
input <-readline()  #문장을 통째로 읽어냄 (단어마다 자르지 않고)
input <-readline("Are you ok? : ")  #사용자 인풋 이전에 커서 깜박이랑 메세지 뜨게 하는거
input <-readLines('scan_4.txt')  #중간에 L 이 대문자! --> 문장으로 읽어라는 명령
input
#table 형태로 만들어진 자료 (그러나 정확한 표라기보다는 스페이스 등으로 나눈 자료) 를 읽을 때는 read.table()
fruits <-read.table('fruits.txt') ; fruits
fruits <- read.table('fruits.txt', header=T) ; fruits   #read.table(파일, headr=T) -->내가 주는 파일 첫 줄이 헤더이다
#이 파일에는 원래 중간에 #으로 쓰인 Non-data 가 포함되어있었음. 그건 자동으로 거름
fruits <- read.table('fruits_2.txt') ; fruits
fruits <- read.table ('fruits_2.txt', skip=2) ; fruits #위에서부터 몇 줄을 스킵하고 읽어라
fruits <- read.table ('fruits_2.txt', nrows=2) ; fruits  #위에서부터 몇 줄만 읽어라
nrow(read.table('fruits_2.txt'))
f2top <- read.table ('fruits_2.txt', nrows=((nrow(read.table('fruits_2.txt')))/2)) ; f2top
f2middle <- read.table ('fruits_2.txt', skip=2, nrows=2) ; f2middle  #skip 과 nrows 를 함께 사용해서 중간부분 자르기
#csv 파일은 , 로만 구분이 되어있어도 excel, R, Python 등 다 읽을 수 있음
fruits <-read.csv('fruits_3.csv') ; fruits #csv 파일은 헤더를 디폴트로 가지고 있다고 간주 -> headr=T없이도 자동으로 첫 줄을 헤더화화
#본래 csv 파일에 header 로 쓰일 첫 줄이 없을 경우 header=F 를 표시
fruits <- read.csv('fruits_4.csv', header=F); fruits
#이 때 수동으로 header 을 간단히 지정하자면 read.csv('  .csv', header=F, col.names=...) 로 쓴다
label <- c("no", "name", "price", "qty")
fruits <- read.csv('fruits_4.csv', header=F, col.names=label) ; fruits
install.packages("googleVis")
library(googleVis)
install.packages("sqldf")
library(sqldf)
Fruits  #package 를 인스톨 하면서 주어진 테스트 데이터
#어떤 데이터를 csv 파일로 저장하는 것--> write.csv(데이터, "...csv", quote=F, row.names=F)
write.csv(Fruits, "Fruits_sql.scv", quote = F, row.names=F)
read.csv(Fruits_sql.scv)
read.csv("Fruits_sql.scv")
fruits_2 <-read.csv.sql("Fruits_sql.csv", sql="SELECT * FROM file WHERE Year = 2008")
#Load and Save Data
#작업용 기본 working directory 를 R Studio Tools->gobal->working direc 에서 data 폴더로 설정
list.files()  # working direc의 저장된 모든 파일 이름들 보여줌
list.files(all.files = T) #숨김 파일까지 보여줌
scan1 <- scan('scan_1.txt') ; scan1
scan2 <- scan('scan_2.txt') ; scan2 #소수점 데이터 포함하는데 그것이 제대로 읽히질 않음
scan2 <- scan('scan_2.txt', what= "") ; scan2 #소수점 데이터를 제대로 읽는대신 캐릭터/스트링으로 변환시켜 내보냄
scan3 <-scan ('scan_3.txt', what="") ; scan3 #what="" 가 스트링 관련
scan4 <-scan ('scan_4.txt', what="") ; scan4 #스트링들은 그냥 스트링으로 나옴
input<-scan()  #사용자로부터 input 받음
input <- scan(what="")
input <-readline()  #문장을 통째로 읽어냄 (단어마다 자르지 않고)
input <-readline("Are you ok? : ")  #사용자 인풋 이전에 커서 깜박이랑 메세지 뜨게 하는거
input <-readLines('scan_4.txt')  #중간에 L 이 대문자! --> 문장으로 읽어라는 명령
input
#table 형태로 만들어진 자료 (그러나 정확한 표라기보다는 스페이스 등으로 나눈 자료) 를 읽을 때는 read.table()
fruits <-read.table('fruits.txt') ; fruits
fruits <- read.table('fruits.txt', header=T) ; fruits   #read.table(파일, headr=T) -->내가 주는 파일 첫 줄이 헤더이다
#이 파일에는 원래 중간에 #으로 쓰인 Non-data 가 포함되어있었음. 그건 자동으로 거름
fruits <- read.table('fruits_2.txt') ; fruits
fruits <- read.table ('fruits_2.txt', skip=2) ; fruits #위에서부터 몇 줄을 스킵하고 읽어라
fruits <- read.table ('fruits_2.txt', nrows=2) ; fruits  #위에서부터 몇 줄만 읽어라
nrow(read.table('fruits_2.txt'))
f2top <- read.table ('fruits_2.txt', nrows=((nrow(read.table('fruits_2.txt')))/2)) ; f2top
f2middle <- read.table ('fruits_2.txt', skip=2, nrows=2) ; f2middle  #skip 과 nrows 를 함께 사용해서 중간부분 자르기
#csv 파일은 , 로만 구분이 되어있어도 excel, R, Python 등 다 읽을 수 있음
fruits <-read.csv('fruits_3.csv') ; fruits #csv 파일은 헤더를 디폴트로 가지고 있다고 간주 -> headr=T없이도 자동으로 첫 줄을 헤더화화
#본래 csv 파일에 header 로 쓰일 첫 줄이 없을 경우 header=F 를 표시
fruits <- read.csv('fruits_4.csv', header=F); fruits
#이 때 수동으로 header 을 간단히 지정하자면 read.csv('  .csv', header=F, col.names=...) 로 쓴다
label <- c("no", "name", "price", "qty")
fruits <- read.csv('fruits_4.csv', header=F, col.names=label) ; fruits
install.packages("googleVis")
library(googleVis)
install.packages("sqldf")
library(sqldf)
Fruits  #package 를 인스톨 하면서 주어진 테스트 데이터
#어떤 데이터를 csv 파일로 저장하는 것--> write.csv(데이터, "...csv", quote=F, row.names=F)
write.csv(Fruits, "Fruits_sql.csv", quote = F, row.names=F)
read.csv("Fruits_sql.csv")
fruits_2 <-read.csv.sql("Fruits_sql.csv", sql="SELECT * FROM file WHERE Year = 2008")
install.packages("sqldf")
#Load and Save Data
#작업용 기본 working directory 를 R Studio Tools->gobal->working direc 에서 data 폴더로 설정
list.files()  # working direc의 저장된 모든 파일 이름들 보여줌
list.files(all.files = T) #숨김 파일까지 보여줌
scan1 <- scan('scan_1.txt') ; scan1
scan2 <- scan('scan_2.txt') ; scan2 #소수점 데이터 포함하는데 그것이 제대로 읽히질 않음
scan2 <- scan('scan_2.txt', what= "") ; scan2 #소수점 데이터를 제대로 읽는대신 캐릭터/스트링으로 변환시켜 내보냄
scan3 <-scan ('scan_3.txt', what="") ; scan3 #what="" 가 스트링 관련
scan4 <-scan ('scan_4.txt', what="") ; scan4 #스트링들은 그냥 스트링으로 나옴
input<-scan()  #사용자로부터 input 받음
input <- scan(what="")
input <-readline()  #문장을 통째로 읽어냄 (단어마다 자르지 않고)
input <-readline("Are you ok? : ")  #사용자 인풋 이전에 커서 깜박이랑 메세지 뜨게 하는거
input <-readLines('scan_4.txt')  #중간에 L 이 대문자! --> 문장으로 읽어라는 명령
input
#table 형태로 만들어진 자료 (그러나 정확한 표라기보다는 스페이스 등으로 나눈 자료) 를 읽을 때는 read.table()
fruits <-read.table('fruits.txt') ; fruits
fruits <- read.table('fruits.txt', header=T) ; fruits   #read.table(파일, headr=T) -->내가 주는 파일 첫 줄이 헤더이다
#이 파일에는 원래 중간에 #으로 쓰인 Non-data 가 포함되어있었음. 그건 자동으로 거름
fruits <- read.table('fruits_2.txt') ; fruits
fruits <- read.table ('fruits_2.txt', skip=2) ; fruits #위에서부터 몇 줄을 스킵하고 읽어라
fruits <- read.table ('fruits_2.txt', nrows=2) ; fruits  #위에서부터 몇 줄만 읽어라
nrow(read.table('fruits_2.txt'))
f2top <- read.table ('fruits_2.txt', nrows=((nrow(read.table('fruits_2.txt')))/2)) ; f2top
f2middle <- read.table ('fruits_2.txt', skip=2, nrows=2) ; f2middle  #skip 과 nrows 를 함께 사용해서 중간부분 자르기
#csv 파일은 , 로만 구분이 되어있어도 excel, R, Python 등 다 읽을 수 있음
fruits <-read.csv('fruits_3.csv') ; fruits #csv 파일은 헤더를 디폴트로 가지고 있다고 간주 -> headr=T없이도 자동으로 첫 줄을 헤더화화
#본래 csv 파일에 header 로 쓰일 첫 줄이 없을 경우 header=F 를 표시
fruits <- read.csv('fruits_4.csv', header=F); fruits
#이 때 수동으로 header 을 간단히 지정하자면 read.csv('  .csv', header=F, col.names=...) 로 쓴다
label <- c("no", "name", "price", "qty")
fruits <- read.csv('fruits_4.csv', header=F, col.names=label) ; fruits
install.packages("googleVis")
library(googleVis)
install.packages("sqldf")
library(sqldf)
Fruits  #package 를 인스톨 하면서 주어진 테스트 데이터
#어떤 데이터를 csv 파일로 저장하는 것--> write.csv(데이터, "...csv", quote=F, row.names=F)
write.csv(Fruits, "Fruits_sql.csv", quote = F, row.names=F)
read.csv("Fruits_sql.csv")
fruits_2 <-read.csv.sql("Fruits_sql.csv", sql="SELECT * FROM file WHERE Year = 2008")
fruits_2
#fruits_2 는 데이터 프레임인데 여기서 Date 이라는 factor 에서 2008년 것을 subset으로 뽑는 것
subset(fruits_2, Profit > 20)
#DATA FRAME
no <- c(1:4)
name <- c("A", "B","C", "D")
price <- c(500:503)
qty <- c(4:1)
#각각 만들어진 벡터들을 칼럼화 -> data.frame(A=a, B=b...) : A,B=data frame의 칼럼네임, a,b=개별 벡터
sales <- data.frame(NO=no, NAME=name, PRICE=price,QTY=qty)
sales
# Matrix --> Data Frame
sales2<- matrix(c(1,"A",500,4, 2,"B", 200,2), nrow=2, byrow=T)
sales2 #Matrix는 모양은 데이터프레임과 비슷하지만  모든 숫자까지 다 character로 변환됨 " "
sales2<- data.frame(sales2)
sales2 # data.frame() 함수가 자동으로 메트릭스 내용을 읽고 캐릭터화된 숫자도 다시 원상복귀시킴
df1 <-data.frame(sales2)
names(df1) <- c('NO', 'NAME', 'PRICE', 'QTY')  #dataframe 에게 name 을 주는 것
df1
#List 에서 Key 아래 Value 값들을 부르듯이 data frame 도 동일 방법 사용
#이 때 출력되는 값들은 더이상 "" 캐릭터가 아니라 factor 클래스에 속함
sales$NAME
class(df1$NAME)
sales[1,3]   # vector, matrix, array 와 모두 같은 방법 still available!
sales[,3]
sales[2,]
sales[c(1,2),]    #한 번에 mulitple rows/columns 를 표시하고 싶을 때는 해당 부분에 c(a,b,c..)
sales[,c(1,2),]
#조건식 --> subset(데이터프레임, 조건)
subset(sales, QTY<3)
subset(sales, QTY==3)  # == (이퀄이 두개) -> A 와 b 가 같다
subset(sales, QTY!=3)  # ! = --> != 표시로 자동바뀜
subset(sales, NAME=="B")
no <- c(1,2,3)
name <- c('a', 'b', 'c')
price <- c(100,200,300)
df1 <-data.frame(NO=no, NAME=name, PRICE=price)
df1
no <- c(3,5,6)
name <- c('c', 'e', 'f')
price <- c(300,500,600)
df2 <-data.frame(NO=no, NAME=name, PRICE=price)
df2
#dataframe 을 rbind(), cbind(), merge() 를 사용하여 합쳐보자
df3 <-cbind(df1, df2) ; df3  #cbind() 사용 (칼럼끼리 합침) --> row 행의 개수는 유지하고 칼럼을 늘리는것 것
df3$NAME  #이 경우 같은 이름의 칼럼 중에 먼저 있는 걸 출력
df4 <-rbind(df1, df2) ; df4  #rbind() 사용 (행끼리 합침)--> 칼럼유지, 행을 늘림
df4$NAME
df1 <- data.frame(NAME=c('a','b','c'), PRICE=c(300,200,100))
df2 <- data.frame(NAME=c('a','d','c'), QTY = c(5,4,3))
## Merge data frame --> SQL 의 Inner / Outer Join 과 비슷.
#동일 factor (여기선 NAME) 이 있을 때, 그리고 그 중에서 같은 데이터가 있을 때
#그것들에 해당하는 데이터만 모아서 merge 하는것
df5 <-merge(df1, df2) ; df5  #InnerJoin: 교집합 격인 NAME='a', 'c' 관련 df1-PRICE 값과 df2-QTY 를 합침
df6 <-merge(df1, df2, all =T) ; df6 #OuterJoin: 교집합 제외 나머지 자료까지 모두 추가 (빈 부분은 NA로 채움)
new <-data.frame(NAME= "mango", PRICE=400)
df5 <-rbind(df1,new) ; df5
df5 <-cbind(df1, data.frame(QTY=c(2,3,4))) ; df5
no <- c(1,2,3,4,5)
name <- c("a", "b","c","d","e")
address <- c("AB", "CD", "EF", "GH", "IJ")
tel <- c(1111,22222,3333,444,5555)
hobby <- c("f","g","h","i","j")
member <-data.frame (NO=no, NAME=name, ADDRESS = address, TEL=tel, HOBBY=hobby)
member
# subset(데이터프레임, select=XX): select=낱개의 factor or c(A, B)도 가능, 특정 항목을 선택하는 것
subset(member, select=c(NAME, TEL))
subset(member, select=-TEL)
#colnames(데이터프레임) <- c(새로운 팩터이름들) : 칼럼의 팩터이름들을 수정 저장
colnames(member) <- c("번호","이름","주소","번호","취미") ;member
ncol(member)  # ncol(데이터프레임) : 칼럼 개수
nrow(member)  # nrow(데이터프레임) : 행 개수
names(member) # names(데이터프레임) : 칼럼팩터 이름들
rownames(member) # 행들의 이름 --> 본래 1~n으로 그냥 몇 번째 행인지 표시
rownames(member) <- c("one", "two", "three", "four", "five") #rownames()<-새로운 값그룹 으로 수정저장 가능
rownames(member)
member  #한번 수정되면 그대로 저장됨
subset(sales, NAME=="B")
# Matrix --> Data Frame
sales2<- matrix(c(1,"A",500,4, 2,"B", 200,2), nrow=2, byrow=T)
sales2 #Matrix는 모양은 데이터프레임과 비슷하지만  모든 숫자까지 다 character로 변환됨 " "
sales2<- data.frame(sales2)
sales2 # data.frame() 함수가 자동으로 메트릭스 내용을 읽고 캐릭터화된 숫자도 다시 원상복귀시킴
df1 <-data.frame(sales2)
names(df1) <- c('NO', 'NAME', 'PRICE', 'QTY')  #dataframe 에게 name 을 주는 것
df1
#List 에서 Key 아래 Value 값들을 부르듯이 data frame 도 동일 방법 사용
#이 때 출력되는 값들은 더이상 "" 캐릭터가 아니라 factor 클래스에 속함
sales$NAME
class(df1$NAME)
sales[1,3]   # vector, matrix, array 와 모두 같은 방법 still available!
sales[,3]
sales[2,]
sales[c(1,2),]    #한 번에 mulitple rows/columns 를 표시하고 싶을 때는 해당 부분에 c(a,b,c..)
sales[,c(1,2),]
#조건식 --> subset(데이터프레임, 조건)
subset(sales, QTY<3)
subset(sales, QTY==3)  # == (이퀄이 두개) -> A 와 b 가 같다
subset(sales, QTY!=3)  # ! = --> != 표시로 자동바뀜
subset(sales, NAME=="B")
#fruits_2 는 데이터 프레임인데 여기서 Date 이라는 factor 에서 2008년 것을 subset으로 뽑는 것
fruits_2
#fruits_2 는 데이터 프레임인데 여기서 Date 이라는 factor 에서 2008년 것을 subset으로 뽑는 것
read.csv("Fruits_sql.csv")
#fruits_2 는 데이터 프레임인데 여기서 Date 이라는 factor 에서 2008년 것을 subset으로 뽑는 것
ftest<-read.csv("Fruits_sql.csv")
ftest$Profit
subset(ftest, Profit>10)
subset(ftest, 10<Profit<15)
subset(ftest, ((Profit>10) & (Profit <16)
subset(ftest, ((Profit>10) & (Profit <16)))
subset(ftest, (Profit>10 & Profit <16))
install.packages("XLConnect")
library(XLConnect)
data1<-loadWorkbook("fruits_6.xls", create=T)
data2<-readWorkbook(data1, sheet="sheet1", startRow=1, endRow=8, startCol=1, endCol=5)
data2<-readWorksheet(data1, sheet="sheet1", startRow=1, endRow=8, startCol=1, endCol=5)
data2
ftest$Date
ftest$Date[1]
ftest$Date[,1]
ftest$Date[1] < as.Date("2008-01-01")
##############################################
install.packages('readxl')
library(readxl)
cust_profile <-read.excel("fruits_6.xls", #path
sheet = "Sheet1", #sheet name to read from
range="A2:D6", #cell range to read from
col_names=TRUE, #TRUE to use the first row as column names
col_types="guess", #guess the type of columns
na="NA" #
)
fruits6
fruits6<-read.delim("clipboard", header=T)
data1<-loadWorkbook("fruits_6.xls", create=T)
data2<-readWorksheet(data1, sheet="sheet1", startRow=1, endRow=8, startCol=1, endCol=5)
data2
fruits6<-read.delim("clipboard", header=T)
cust_profile <-read.excel("fruits_6.xls", #path
sheet = "sheet1", #sheet name to read from
range="A2:D6", #cell range to read from
col_names=TRUE, #TRUE to use the first row as column names
col_types="guess", #guess the type of columns
na="NA" #
)
Years("2007-01-01")
year("2007-01-01")
library(lubridate)
year("2007-01-01")
year("2007-01-01") - year("2006-01-01")
ftest$Date[1,1]
ftest$Date[2]
year(ftest$Date)
subset(ftest, year(ftest$Date)-year("2008-01-01") == 0)
subset(ftest, year(ftest$Date)-year("2008-01-01") == 0)
View(df4)
subset(ftest, year(ftest$Date) == 2008)
ftest<-read.csv("Fruits_sql.csv")
ftest$Profit
subset(ftest, Profit>10)
subset(ftest, (Profit>10 & Profit <16))
ftest$Date
ftest$Date[2]
library(lubridate)
year("2007-01-01") - year("2006-01-01")
year(ftest$Date)
subset(ftest, year(ftest$Date) == 2008)
