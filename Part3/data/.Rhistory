#R은 script라고 불린다. High level lang 은 크게 Compile vs. Interpret
#Compile 은 Java, C      vs.     Interpret 은 R, Python
setwd ("D:\Workspace\R_data_analysis\Part3/data")
#R은 script라고 불린다. High level lang 은 크게 Compile vs. Interpret
#Compile 은 Java, C      vs.     Interpret 은 R, Python
#먼저 코딩을 하다가 Run (ctrl + Enter) 을 누르면 한 줄 씩 읽고 실행하는 방식
print (3)
print (4)
getwd()
1+2
print(1+2)
1+2
#문자입력시 '' 필수. print 없이 ''로 해도 상관없음
print( 'a' )
#문자입력시 '' 필수. print 없이 ''로 해도 상관없음
print('a')
"a"
'a'
source('~/.active-rstudio-document', encoding = 'UTF-8', echo=TRUE)
'a'
setwd ("D:\Workspace\R_data_analysis\Part3/data")
#R은 script라고 불린다. High level lang 은 크게 Compile vs. Interpret
#Compile 은 Java, C      vs.     Interpret 은 R, Python
#먼저 코딩을 하다가 Run (ctrl + Enter) 을 누르면 한 줄 씩 읽고 실행하는 방식
print (3)
print (4)
#현재 활동 working directory 주소
getwd()
#print(행동) 을 하던 그냥 행동을 명령하던 둘다 화면에 결과 출력됨
print(1+2)
1+2
#문자입력시 '' 필수. print 없이 ''로 해도 상관없음
print('a')
'a'
print(pi, digits=3)
print(3,4)
print(pi, digits=3)
#작업용 기본 디렉토리 설정은 setwd (디렉토리 주소)
setwd ("D:\Workspace\R_data_analysis\Part3/data")
#R은 script라고 불린다. High level lang 은 크게 Compile vs. Interpret
#Compile 은 Java, C      vs.     Interpret 은 R, Python
#먼저 코딩을 하다가 Run (ctrl + Enter) 을 누르면 한 줄 씩 읽고 실행하는 방식
print (3)
print (4)
#현재 활동 working directory 주소
getwd()
#print(행동) 을 하던 그냥 행동을 명령하던 둘다 화면에 결과 출력됨
print(1+2)
1+2
#문자입력시 '' 필수. print 없이 ''로 해도 상관없음. "" 도 사용가능.
print('a')
'a'
#이미 정해진 숫자변수 등은 이름으로 (pi 등) 쳐도 가능. pi, digits=# 으로 주면 #만큼의 소수점만 표시
print(pi)
#print(pi, digits=3)
print(3,4)
#작업용 기본 디렉토리 설정은 setwd (디렉토리 주소)
setwd ("D:\Workspace\R_data_analysis\Part3/data")
#R은 script라고 불린다. High level lang 은 크게 Compile vs. Interpret
#Compile 은 Java, C      vs.     Interpret 은 R, Python
#먼저 코딩을 하다가 Run (ctrl + Enter) 을 누르면 한 줄 씩 읽고 실행하는 방식
print (3)
print (4)
#현재 활동 working directory 주소
getwd()
#print(행동) 을 하던 그냥 행동을 명령하던 둘다 화면에 결과 출력됨
print(1+2)
1+2
#문자입력시 '' 필수. print 없이 ''로 해도 상관없음. "" 도 사용가능.
print('a')
'a'
#이미 정해진 숫자변수 등은 이름으로 (pi 등) 쳐도 가능. pi, digits=# 으로 주면 #만큼의 소수점만 표시
print(pi)
print(pi, digits=3)
#두 수를 한 괄호안에 따옴표 등 없이 넣으면 첫번째 수 하나만 출력
print(3,4)
print('a', 'b')
cat(1, ':', 'a', '\n', 5)
3,4
3 ','4
3; 4; 5
3; 'a'; 4
1+2; pi*5*5; 'ab'
#Data Type
#R에서는 data type 을 별로 따지지 않음
5/2
#Data Type
#R에서는 data type 을 별로 따지지 않음
5/2
3/4
3%4
4%4
print(4%4)
print(4 % 4)
3%/%4
#나눗셈의 나머지 %%
3%%4
#나눗셈의 나머지 %%
5%%4
1000000000000
1000000000000+10000000
1/100000000000
'1'+'2'
# ''에 쌓인 숫자는 더이상 numeric variable 이 아닌 문자로 취급
#'1'+'2'
as.numeric('1'+'2')
# ''에 쌓인 숫자는 더이상 numeric variable 이 아닌 문자로 취급
#'1'+'2'
as.numeric('1') + as.numeric('2')
'first'
"second"
first
first <- 1
first
class(1)
class('1')
class('1')
3 & 9
1 & 'a'
source('D:/Workspace/R_data_analysis/Part3/sec_4.R', encoding = 'UTF-8', echo=TRUE)
1 | 4
3 & 0
source('D:/Workspace/R_data_analysis/Part3/sec_4.R', encoding = 'UTF-8', echo=TRUE)
3 & -1
3 & o
1 | 0
1 | 0
3 & 0
1 | 0
#Data Type
#R에서는 data type 을 별로 따지지 않음
5/2
3/4
#나눗셈의 몫 %/%
3%/%4
#나눗셈의 나머지 %%
5%%4
1000000000000+10000000
1/100000000000
# ''에 쌓인 숫자는 더이상 numeric variable 이 아닌 문자로 취급
#'1'+'2'
#as.numeric() 을 이용하면 문자형식을 숫자로 치환할 수 있음.
as.numeric('1') + as.numeric('2')
#변수 설정 및 대입 : 대입은 <-
first <- 1
first
#class() 입력값의 data type 출력
class(1)
class('1')
#and &, or |
#-> 그냥 숫자끼리 비교할 때 0만 아니면 낱개들은 다 TRUE 임. 0 은 이진수로도 0이라서 FALSE 값
#T & T -> T, T & F -> T, F & F -> F
#T | T -> T, T | F -> T, F | F -> F
3 & 9
3 & 0
1 | 4
1 | 0
class(0)
class(3 & 9)
#NA: 잘못된 값 들어옴 (Not Applicable), NULL: 값이 안 나옴.
cat(1,NA,2)
cat(1,NULL,2)
sum(1,NA,2)
sum(1,NULL,2)
sum(1,NULL,2)
sum(1, NA, 2, na.rm = T)
class(NULL)
class(NULL)
class(NA)
#작업용 기본 디렉토리 설정은 setwd (디렉토리 주소)
setwd ("D:\Workspace\R_data_analysis\Part3/data")
txt1
txt1 <- read.csv("factor_test.csv")
txt1
txt1
txt1 <- read.csv("factor_test.csv")
txt1 <- read.csv("factor_test.txt")
txt1 <- read.csv("factor_test.txt")
class(factor2)
class(factor2)
#Data Type
#R에서는 data type 을 별로 따지지 않음
5/2
3/4
#나눗셈의 몫 %/%
3%/%4
#나눗셈의 나머지 %%
5%%4
1000000000000+10000000
1/100000000000
# ''에 쌓인 숫자는 더이상 numeric variable 이 아닌 문자로 취급
#'1'+'2'
#as.numeric() 을 이용하면 문자형식을 숫자로 치환할 수 있음.
as.numeric('1') + as.numeric('2')
#변수 설정 및 대입 : 대입은 <-
first <- 1
first
#class() 입력값의 data type 출력
class(1)      #numeric
class('1')    #character
#and &, or |
#-> 그냥 숫자끼리 비교할 때 0만 아니면 낱개들은 다 TRUE 임. 0 은 이진수로도 0이라서 FALSE 값
#T & T -> T, T & F -> F, F & F -> F
#T | T -> T, T | F -> T, F | F -> F
3 & 9
3 & 0
1 | 4
1 | 0
class(3 & 9)    #TRUE, FALSE 는 logical 클래스
#NA: 잘못된 값 들어옴 (Not Applicable), NULL: 값이 안 나옴.
cat(1,NA,2) #단순 출력이므로 NA 는 상관없음
cat(1,NULL,2) #NULL 은 아예 값이 없으므로 출력이 안됨
sum(1,NA,2) #덧셈연산에 NA는 해당이 안 되므로 계산자체가 불가능
sum(1,NULL,2) #덧셈에서 NULL = 0 과 같으므로 상관 없음
#na.rm = T, NA 값 = True 라면 remove 해라
sum(1, NA, 2, na.rm = T)
class(NA)     #NA 는 logical 클래스
class(NULL)   #NULL 은 자체로 NULL 클래스
#작업용 기본 디렉토리 설정은 setwd (디렉토리 주소)
setwd ("D:/Workspace/R_data_analysis/Part3/data")
txt1 <- read.csv("factor_test.txt") #read.csv(~.csv) 주어진 csv 파일을 읽어서 변수에 대입
txt1
factor1 <- factor(txt1$no) #factor(csv대입변수이름$데이터를 구분하는 열의 이름)
#                           특정데이터의 자료들을 출력 (그 열의 행자료들을 출력)
factor1
factor2 <- factor(txt1$sex)
factor2
summary1 <- summary(factor2) #summary() 특정데이터 자료들을 빈도에 따라 정리, 출력
summary1
class(factor(txt1$sex))
class(factor2)
Sys.Date()
Sys.time()
source('D:/Workspace/R_data_analysis/Part3/sec_4.R', encoding = 'UTF-8', echo=TRUE)
class(Sys.date())
date()       #미국 식 시간표기 : Thu May 30 09:16:47 2019
class(Sys.Date())
as.Date("2019-05-30")
class(d)
#"2019-05-30"을 그냥 type하면 character 클래스. 이것을 date 타입으로 바꾸기위해 as.Date(" ")을 사용
d <- as.Date("2019-05-30")
class(d)
#"2019-05-30"을 그냥 type하면 character 클래스. 이것을 date 타입으로 바꾸기위해 as.Date(" ")을 사용
class("2019-05-30")
as.Date("19-05-30")
as.Date("05-30-2019", format="%d-%m-%Y")
as.Date("30-05-2019", format="%d-%m-%Y")
as.Date("190530", format="%y-%m-%d")
as.Date("190530", format="%y%m%d")
as.Date("2019년 05월 30일", format="%Y년 %m월 %d일")
as.Date("05-30", format="%m-%d")
as.Date(10, origin="2019-05-30")
as.Date(10, origin=Sys.date())
as.Date(10, origin=Sys.Date())
"2019-05-30" - "2019-05-27"
as.Date("2019-05-30") - as.Date("2019-05-27")
as.Date("2019-11-14") - Sys.Date()   #as.Date으로 변환 후에는 가능함
as.Date("2019-05-30 20:00:00") - as.Date("2019-05-30 12:00:00")
as.POSIXct("2019-05-30 20:00:00") - as.POSIXct("2019-05-30 12:00:00")
as.POSIXct("2019-05-30 20:00:00") - as.POSIXct("2019-05-30 12:00:00")  #POSIXct 초 단위로 ㄱㄱ
as.POSIXct("2019-05-30 20:00:00") - as.POSIXct("2019-05-30 12:10:04")  #POSIXct 초 단위로 계산한 시간차를 출력 (초 말고 보기 쉬운 더 큰 단위로 출력됨)
install.packages("lubridate")
library(lubridate)
now
now()
year(date)
month(date)
date <- now() #lubridate 설치 후 더 빠르게 바뀐, 새로운 함수
month(date)
month(d)
wday(date)
day(date)
wday(date, label = T)
month(date, label=T)
d <- d - days(2)
d
d + years(1)
d+months(-3)
d+months(-2)
d-months(2)
d
d
d <- hm("22:30")
d
d
d <- hms("22:30:14")   #hms --> hours, minutes, seconds 시간,분,초 대입
d
var <- c("a","b","c")
source('D:/Workspace/R_data_analysis/Part3/sec_5.R', encoding = 'UTF-8', echo=TRUE)
111->var1->var2
var1 ; var2
var3 ; var4
var3 ; var4
var3 <- var4<-222
var3 ; var4
var <- c(1, 2, 3)
var
111->var1->var2     #값을 연속적으로 할당
var3 ; var4
string1 <- "V Easy R Programming" ; string1
string2 <- 'he said "I ate breakfast"'
string2 <- 'he said "I ate breakfast"' ; string2
var <- c("a","b","c")   #a, b, c 라는 각각의 문자 데이터를 한번에 담음 --> Array 형태
var
var <- c(1, 2, 3)
var
111->var1->var2     #값을 연속적으로 할당
var1 ; var2
var3 <- var4<-222   #rotation 할당 화살표 방향은 아무쪽이나 상관없다
var3 ; var4
string1 <- "V Easy R Programming" ; string1
string2 <- 'V Easy R'
string3 <- 'he said "I ate breakfast"' ;
string3  #"" 를 '' 안에 넣으면 큰따옴표 대신 백슬래쉬 사이에 대화체로 묶는다
string2 <- 'V Easy R' ; string2
string3  #"" 를 '' 안에 넣으면 큰따옴표 대신 백슬래쉬 사이에 대화체로 묶는다
strnig4
string4 <- 'he said /"I ate breakfast"/'
strnig4
string4
string3  # " " 를 ' ' 안에 넣으면 큰따옴표 앞뒤로로 백슬래쉬 사이에 대화체로 묶는다
string4
string4 <- 'he said \"I ate breakfast"\'
string4
string4 <- 'he said \"I ate breakfast"\'
string4
string4 <- 'he said \"I ate breakfast"\'
string4
string4 <- 'he said \"I ate breakfast"\'
string4
string4 <- 'he said \"I ate breakfast\"'
string4 <- "he said \"I ate breakfast\""
num1 + num2
var <- c("a","b","c")   #a, b, c 라는 각각의 문자 데이터를 한번에 담음 --> Array 형태
var
var <- c(1, 2, 3)
var
111->var1->var2     #값을 연속적으로 할당
var1 ; var2
var3 <- var4<-222   #rotation 할당 화살표 방향은 아무쪽이나 상관없다
var3 ; var4
string1 <- "V Easy R Programming" ; string1
string2 <- 'V Easy R' ; string2     #작은 따옴표로 묶어도 문자열은 무조건 "  " 로 출력됨
string3 <- 'he said "I ate breakfast"' ;
string3  # " " 를 ' ' 안에 넣으면 큰따옴표 앞뒤로 백슬래쉬 사이에 대화체로 묶는다
string4 <- "he said \"I ate breakfast\""
string4
num1 <- 1
num2 <- 2
num1 + num2
char1 <- "a"
num1 + char1
seq1 <- 1:5 ; seq1
#이러한 기능은 Python 에도 적용. 이러한 점이 엄청난 양의 데이터를 분석할 때 도움이 된다
seq1 <- "a":"f"
date1 <- seq(from=Sys.Date(), to=(Sys.Date() + months(1)) , by=1)
date1
date2
date2 <- seq(from=Sys.Date(), to=(Sys.Date() + years(1)) , by='month')
date2
date3 <- seq(from=as.Date('2014-04-29'), to=Sys.Date(), by='year')
date3
Objects
objects()
.hidden <-3
objects()
.hidden
rm(date1)
objects()
ls
ls()
rm(list = ls())
ls()
ls()
objects()
.hidden
vec1 <- c(1,2,3,4,5)
vec1 <- c(1:5)
vec1
# CRUD (Create Retrieve Update Delete)
vec1(3)
# CRUD (Create Retrieve Update Delete)
vec1[3]
vec1[-3]
vec1[-1:3]  # 벡터배열을 출력할때 주어진 인덱스 넘버의 값만 빼고 보여줌
source('D:/Workspace/R_data_analysis/Part3/sec_6.R', encoding = 'UTF-8', echo=TRUE)
length(vec1)
vec1[1:(length(vec1)-1)]
vec1[3] <- 2 ; vec1
vec1[3] <- 6 ; vec1
vec1 <- c(vec1, 7, 8) ; vec1
vec1[9] <- 9 ; vec1
vec1
append (vec1, 10, after=3)
append (vec1, c(-1, -2), after=8)
vec1
append (vec1, c(-1, -2), after=7)
vec1 <- append (vec1, c(-1, -2), after=7)
vec1
vec1 <- append(vec1, 100, after=0)
vec1
c(1,2,3) + c(4,5,6)
c(1,2,3) + 1
var1 <- c(1,2,3) ; var2 <- c(4,5,6)
var1+var2
var3 <- c('1','2','3')
var1 + var3
union(var1, var3)
union(var1, var3) #
#union(배열1, 2: 다른 클래스여도 됨) --> 합집합 만듦. 이 때 말 그대로 교집합, 겹치는 값은 제외, 중복 없는 결과
var4 <- c(1,2,3,4,5)
var1; var4
var1 + var4
#이 때 짧은 벡터를 그것이 끝난 부분부터 다시 1로 돌아와서 연산
var5 <- c(1,2,3,4,5,6)
var1 + var5
#이 때 짧은 벡터를 그것이 끝난 부분부터 다시 1로 돌아와서 연산
var5 <- c(1,2,3,4,5,6,7)
var1 + var5
var1 + var5   #여기서는 var5가 더 길지만 길이가 6으로 var1 의 길이는 3, 둘은 배수이므로 warning 없음음
source('D:/Workspace/R_data_analysis/Part3/sec_6.R', encoding = 'UTF-8', echo=TRUE)
var1 + var5   #여기서는 var5가 더 길지만 길이가 6으로 var1 의 길이는 3, 둘은 배수이므로 warning 없음음
